%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
%   content.tex
%
%   Main content of ACG. To be included as a part of another document.
%
%   This is a part of the Arageli library documentation.
%
%   Copyright (C) 2007 Sergey S. Lyalin
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


Этот документ может служить руководством для программиста,
который добавляет код в Arageli. Она будет полезна и для
пользователя библиотеки, позволит свободно ориентироваться в
исходном коде библиотеки и запомнить названия классов и функций.

Полное название этого документа:
``Правила организации исходного кода Arageli'',
или, что более лаконично, по-английски: ``Arageli Coding Guidelines''.
Поэтому везде далее мы будем ссылаться на эти правила с помощью
простой аббревиатуры ACG.

Рассматривается структура каталога с исходными текстами Arageli,
правила работы с SVN и принципы написания хорошего кода, который
будет отлично сочетаться с другими компонентами библиотеки
(именование объектов, форматирование кода, комментарии,
документирование и т.\,д.).

Прежде всего небольшое замечание по терминологии.
Везде далее, когда речь идёт о классе, то под этим понимаются
не только конструкции, начинающиеся со слова \lstinline$class$,
но и те, которые начинаются с \lstinline$struct$ и \lstinline$union$.
Если это не так, то это специально оговаривается.

\section{Идентификаторы}

О силе имён сказано уже достаточно много (см. например, Совершенный код,
ССЫЛКА). Здесь мы остановимся лишь на технических аспектах именования,
больше заботясь о том, какие символы, в каком регистре и в каком
количестве входят в имя, не сильно касаясь содержательности имён.
Укажем лишь некоторые рекомендации, которым принято следовать в Arageli.

В Arageli мы придерживаемся стиля именования STL, поэтому более предпочтительны
имена в единственном числе, нежели во множественном.
В ACG многое будет напоминать стиль, которым пользуются в STL.

Корневым пространством имён для всех компонент библиотеки является
\lstinline$namespace Arageli$. Все остальные имена, включая возможные подпространства
имён, должны входить в \lstinline$namespace Arageli$. Исключение составляет код,
который расширяют другие библиотеки для достижения большей совместимости
с Arageli. Это касается, прежде всего, STL. Некоторые шаблонные функции STL
специализируются для классов Arageli. Понятно, что код специализации
размещается в \lstinline$namespace std$. Но, этот код всё равно считается частью
Arageli (для него действуют правила, описанные в этом документе).

В зависимости от назначения идентификатора на него накладываются
разные требования. Как уже было сказано, в основном мы придерживаемся
классического стиля STL,
который применительно к Arageli определяется следующими правилами
(все правила ACG кумулятивные, т.\,е. корректное имя должно
удовлетворять \textsl{всем} правилам этого документа):
\begin{itemize}
    \item Все открытые имена (которые предоставляются внешнему
    пользователю библиотеки) любых объектов не могут начинаться с
    символа подчёркивания `\lstinline$_$'. Слова в идентификаторе
    отделяются символом подчёркивания `\lstinline$_$'. Идентификатор
    помимо символов латиницы и символов подчёркивания может включать цифры.
    Следует избегать агрессивных не общепринятых сокращений
    (о списке общепринятых сокращений см. ниже),
    кроме мест, где это не приводит к путанице
    или без сокращения нельзя обойтись из-за громоздкости получаемых
    идентификаторов.
    \item Все имена, которые по какой-либо причине нельзя скрыть
    от пользователя возможностями C++ (т.\,е. с помощью, например,
    ключевого слова \lstinline$private$ внутри класса) начинаются
    с символа подчёркивания `\lstinline$_$' за которым первое слово
    идентификатора может начинаться с заглавной буквы. Но, все имена,
    которые входят в такую скрытую область, следует кодировать так,
    как будто они открытые.
    \item Все открытые имена вложенных в \lstinline$namespace Arageli$
    пространств имён, шаблонов (как функций, так и классов), классов,
    функций, глобальных переменных, полей и функций классов и
    шаблонов классов записываются строчными символами латиницы.
    \item Все открытые имена глобальных и локальных
    (для класса или шаблона класса) символьных констант любого типа,
    элементов перечислений \lstinline$enum$
    записываются прописными символами латиницы.
    Для имён перечислений следует вводить префикс в имени, который
    указывает на принадлежность этого имени к конкретному перечислению.
    Такой префикс может быть сокращением имени перечисления.
    \item Все макросы записываются прописными символами латиницы.
    Первым словом макроса является `\lstinline$ARAGELI$' (перед которым
    может идти символ подчёркивания, если это внутренний макрос,
    скрытый от пользователя). Если макрос имеет локальное действие,
    то его следует удалить по окончанию области использования директивой
    \lstinline$#undef$.
    \item Не смотря на то, что все макросы записываются прописными
    символами, возможны исключения, когда в имя макроса дословно встраивается
    имя какого-либо другого идентификатора, который может быть записан
    строчными символами.
    \item Ни одно имя не начинается с двух символов подчёркивания `\lstinline$__$',
    так как такие имена зарезервированы для C++ и поддерживающих системных
    библиотек.
\end{itemize}

Этот блок правил относится к именам так или иначе видимых внешнему
пользователю библиотеки. Что же касается имён, которые пользователю увидеть не
возможно или не так просто, то для них вводятся некоторые исключения
или дополнения.

\begin{itemize}
    \item Члены классов, которые не видны пользователю кодируются
    так же как и открытые члены. Но, в некоторых случаях, у имени
    члена данных класса есть суффикс `\lstinline$_m$' (от слова
    member). Это полезно в тех случаях, когда кроме этого члена данных
    есть открытая функция доступа к этому члену с тем же именем,
    но без суффикса `\lstinline$_m$'.
    \item Для формальных параметров-типов шаблона имена записываются
    символами латиницы в обоих регистрах: каждое слово начинается с
    прописной буквы, а все остальные символы строчные. Символ
    подчёркивания `\lstinline$_$' для разделения слов не используется.
    В тривиальных случаях, когда это не вызывает путаницы, такие
    имена сокращаются до одной или нескольких прописных букв с индексами,
    например, \lstinline$T$, \lstinline$MT$, \lstinline$T1$ и т.\,д.
    \item Имена типов, которые имеют ограниченную область видимости
    внутри библиотеки (например, внутри класса или функции),
    можно начинать с прописной буквы, а далее формировать по общим
    правилам для открытых имён. Более того, если внутреннее имя
    начать с заглавной буквы, то это будет наглядно сигнализировать
    о том, что оно внутреннее и пользоваться им внешним образом нельзя.
\end{itemize}

\section{Пробельные символы для отступов и разрывов строк}

Для отступов не используется символ табуляции. Символ табуляции
вообще не используется в исходном коде. Вместо одного символа
табуляции на один отступ используется 4 пробела.

Не следует допускать лишних пробелов в конце строки. Некоторые
редакторы позволяют автоматически удалять их перед сохранением файла.

Для выделения синтаксической структуры исходного текста используются
отступы. Величина одного отступа: 4 пробела.

Существует несколько способов разорвать строку: последовательностью
CR LF или одним символом LF. В зависимости от типа файла применяются
различные способы переноса.

\vspace{1cm}
\begin{tabular}{|l|l|}
    \hline
    *.cpp & LF \\
    *.hpp & LF \\
    Makefile & LF \\
    *.py & LF \\
    *.bat & CR LF \\
    *.txt & CR LF \\
    README & LF \\
    LICENSE & LF \\
    Doxyfile & CR LF \\
    *.tex & LF \\
    \hline
\end{tabular}
\vspace{1cm}

\section{Форматирование}

Если на строке находится открывающая `\lstinline${$' или закрывающая
`\lstinline$}$' фигурные скобки, то они должны быть единственными
лексемами на этой строке (за исключением закрывающей скобки класса,
после которой должна идти точка с запятой).
Фигурные скобки располагаются с тем же уровнем отступа, что и объемлющий
контекст.

Например, следующие варианты являются недопустимыми:
\begin{lstlisting}[style=LstSmallStyle]
void f (int a, int b) {
    return a + b;
}
\end{lstlisting}
\begin{lstlisting}[style=LstSmallStyle]
void f (int a, int b) { return a + b; }
\end{lstlisting}
\begin{lstlisting}[style=LstSmallStyle]
void f (int a, int b)
{ return a + b; }
\end{lstlisting}
\begin{lstlisting}[style=LstSmallStyle]
void f (int a, int b)
    {
    return a + b;
    }
\end{lstlisting}
а допустимый вариант такой:
\begin{lstlisting}[style=LstSmallStyle]
void f (int a, int b)
{
    return a + b;
}
\end{lstlisting}
Также допустимым является такой код:
\begin{lstlisting}[style=LstSmallStyle]
void g ()
{}
\end{lstlisting}
и такой
\begin{lstlisting}[style=LstSmallStyle]
void g ()
{
}
\end{lstlisting}
но, не такой:
\begin{lstlisting}[style=LstSmallStyle]
void g () {}
\end{lstlisting}

На одной строке в функции не может находится более одной инструкции
или более одного начала составной инструкции.

Двоеточие перед списком инициализации в конструкторах
должно быть последней лексемой в строке. Сам список
инициализации начинается со следующей строки.

Двоеточие перед списком наследования при определении
класса не может быть в начале строки; оно может находится
в конце строки (как в случае инициализации в конструкторе) или
разделять имя определяемого класса и базовые классы на одной строке,
если вся конструкция имеет приемлемую длину, умещаясь на одной строке.

Двоеточие не может быть первой лексемой в строке. Это правило дополняет
предыдущие два, а также предотвращает случаи, когда хочется перенести
двоеточие на следующую строку в таких конструкциях как метки, метки в
инструкции \lstinline$switch$, условном операторе.

Если в программе есть список сущностей (список аргументов при определении
или вызове функции, список параметров шаблона, список инициализации,
список базовых классов и т.\,д.), то он может записываться только в двух
видах: в горизонтальном или в вертикальном. Т.\,е. если список умещается
в одну строку, то его можно разместить в одной строке. Если он не помещается
в одну строку, то каждый элемент списка помещается в (начинается с) отдельную
строку. Нельзя начать горизонтальный список, а потом перевести его на новую
строку и продолжить перечислять элементы на ней.

Из этого правила есть одно исключение: инициализаторы длинных массивов,
когда каждый инициализатор для элементов достаточно короткий. В таких случаях,
горизонтальное расположение требует слишком длинной строки, а вертикальное ---
слишком большого количества очень коротких строк.
И в том, и в другом случае обозрение такого массива затрудняется. Поэтому
для таких массивов можно использовать гибридное расположение. Например, так
сделано для степеней известных простых чисел Мерсенна:
\begin{lstlisting}[style=LstSmallStyle]
static const unsigned mersen_degrees[] =
{
    2,3,5,7,13,17,19,31,61,89,107,127,521,607,1279,
    2203,2281,3217,4253,4423,9689,9941,11213,19937,
    21701,23209,44497,86243,110503,132049,216091,
    756839,859433,1257787,1398269,2976221,3021377,
    6972593,13466917
};
\end{lstlisting}

Начало определения шаблона, т.\,е. ключевое слово \lstinline$template$
со списком формальных параметров, не может находится на одной строке
с лексемами последующего определения (функции, класса).
Если у определения несколько заголовков с параметрами шаблона
(например, при определении шаблонного метода шаблона класса),
то заголовки не могут находится на одной и той же строке.

Если тело составных инструкций
\lstinline$for$,
\lstinline$if$,
\lstinline$while$
имеет нетривиальный вид, то рекомендуется размещать (начинать)
его на отдельной строке. Это же касается к инструкциям, которые
выполняются по метке \lstinline$case$ в инструкции \lstinline$switch$.

Формальный признак отсутствия аргументов для функции \lstinline$(void)$
не используется. Например, вместо следующего
\begin{lstlisting}[style=LstSmallStyle]
int f (void)
{
    return something;
}
\end{lstlisting}
следует писать просто
\begin{lstlisting}[style=LstSmallStyle]
int f ()
{
    return something;
}
\end{lstlisting}

Следует комментировать большие куски кода либо директивами
препроцессора (\lstinline$#if 0$...\lstinline$#endif$),
либо многострочными комментариями \lstinline$/* ... */$.
Однострочные комментарии путают историю изменений для всех
закомментированных строк, и их лучше использовать только для
одной-двух строк, которые часто меняются. Если же комментируется
строка в чужом коде, где не совсем ясны последствия этого действия,
лучше \textsl{даже одну строку} комментировать с помощью указанных
средств.

Если для функции тип возвращаемого значения, полное имя и список
аргументов не помещаются на одной строке, то их можно разделить
на три строки: на одной --- тип возвращаемого значения, на второй ---
имя функции и на третьей --- список аргументов, если он не слишком
длинный (в противном случае его надо разбить, как это уже описывалось).
Если список аргументов достаточно короткий, то его можно оставить
на одной строке с именем функции.

[Горизонтальные разделители в коде (типа \lstinline$-----------$)?]

В многострочных макросах не надо стараться, что бы завершающие
каждую строку символы обратной косой черты `\lstinline@\@' были выровнены
в одну колонку. Такие конструкции трудно поддерживать при модификации
макроса. При локальной ручной модификации самое худшее, что может
случится, это выход за границы завершающей колонки одной из строк.
В этом случае придётся подвинуть всю колонку вправо, т.\,е. формально
всё тело макроса по строкам будет модифицировано. При автозамене по
нескольким файлам такая операция становится очень трудоёмкой.

Рекомендуется делать отступ в 4 пробела после последнего значимого
символа в строке макроса до завершающего символа косой черты, и при
последующих модификациях не менять числа пробелов.

При определении сущностей в пространствах имён не используются
дополнительные отступы. Т.\,е. корректным вариантом отступов является
\begin{lstlisting}[style=LstSmallStyle]
namespace Arageli
{
namespace subspace
{
class a;
}
class b;
}
\end{lstlisting}
а не такой вариант:
\begin{lstlisting}[style=LstSmallStyle]
namespace Arageli
{
    namespace subspace
    {
        class a;
    }

    class b;
}
\end{lstlisting}
Исключением из этого правила являются некоторые пространства имён,
которые служат контейнерами для набора классов-тегов, например,
\begin{lstlisting}[style=LstSmallStyle]
namespace type_category
{
    class type
    {};

    class matrix :
        public type
    {};

    ...
}
\end{lstlisting}

\section{Исключительные ситуации}

\section{Комментарии и документация}

Все комментарии делаются на английском языке.
Много комментариев не бывает.
Применяется документирование в стиле Doxygen.

Следует следить за свежестью копирайтов в файлах.

\section{Файлы и каталоги}

\subsection{Имена}

Для имён подкаталогов и файлов в дереве каталогов Arageli
используется такие же правила как для имён открытых функций и классов.
То есть они записываются строчными буквами, для отделения слов
используется символ подчёркивания `\lstinline$_$'.

Для файлов используются следующие расширения
\begin{itemize}
    \item `.cpp' для исходных компилируемых файлов на языке C++;
    \item `.hpp' для заголовочных файлов на языке C++;
    \item `.txt' для текстовых файлов;
        \footnote{Под текстовым файлом понимается файл с обычным
        текстом для человека, не содержащий программного кода}
    хотя не все текстовые файлы имеют это расширение, например,
    файл с текстом лицензии LICENSE и, возможно, другие файлы,
    которые принято оставлять без расширения (это в порядке вещей
    для файлов пришедших из операционной системы Linux);
    \item `.bat' для скриптов командной строки cmd в Windows;
    \item `.tex' для файлов на языке \LaTeX.
    \item `.py' для файлов на языке Python.
\end{itemize}

Для файлов, которые используются как шаблоны для новых файлов
определённого типа, имя содержит суффикс \lstinline$_pattern$,
который идёт перед первым расширением файла (перед первой точкой,
если она есть).

\subsection{Дерево каталогов}

Все исходные файлы библиотеки организованы в виде дерева
подкаталогов. Далее рекурсивно перечислены все подкаталоги
корнего каталога Arageli с пояснениями их назначения и
содержимого, а также некоторые файлы:
\begin{description}
    \item [app] Приложения библиотеки. Отдельные программы,
    которые используют различные части библиотеки и могут
    быть запущенны как самостоятельные приложения (многие
    из них запускаются из командной строки).
    \item [bin] Изначально ничего не содержит,
    cлужит хранилищем для строящихся исполняемых файлов
    тестов и приложений.
    \item [build] Содержит все скрипты для сборки библиотеки
    и документации всех видов. Здесь же находятся файлы
    проектов для некоторых версий Microsof Visual C++.
    Содержит подкаталог:
    \begin{description}
        \item [msvs\_2005] Файлы проектов и solution для
        Microsoft Visual C++ .NET 2005.
    \end{description}
    \item [doc] Готовая документация.
    \begin{description}
        \item [src] Исходные тексты документации.
    \end{description}
    \item [example] Исходные тексты примеров и входные
    данные к ним.
    \item [lib] Место, куда собираются бинарники самой
    библиотеки Arageli.
    \item [perf] Исходные тексты и все дополнительные данные
        системы сбора статистики по производительности библиотеки.
    \item [src] Исходные тексты всей библиотеки.
    \item [test] База тестов: все исходные файлы для
    тестирования библиотеки и её приложений.
    \item [tool] Инструменты сторонних производителей и
    те компоненты, которые служат Arageli.
    \begin{description}
        \item [script] Скрипты для поддержания библиотеки,
        в частности для проверки и приведение в соответствие
        с ACG.
    \end{description}
    \item [LICENSE] Файл с лицензией GPL v.2.
    \item [README] Файл с короткими рекомендации, с которых
    стоит начать новому пользователю библиотеки. Содержит
    инструкции по сборке и ссылки на другие ресурсы.
    \item [readme.txt] То же, что и в README файле, но переносы
    строк сделаны для Windows, чтобы его можно было открыть в
    блокноте. Эти два файла по содержимому поддерживаются
    идентичными. Далее при описании мы всегда просто ссылаемся
    на README файл.
    \item [Makefile] Главный сборочный скрипт библиотеки для Linux.
    См.~README для получения инструкций как его использовать.
\end{description}

\section{SVN}

Все исходные коды библиотеки находятся под системой контроля версий.
В настоящий момент разработчики библиотеки используют систему
SubVersion (сокращённо SVN),
поэтому дальнейшее изложение будет опираться на неё.
Выбор SVN для описания правил сделан лишь для того, чтобы предать
изложению конкретный характер. Также это полезно для настоящих
разработчиков.

Если когда-либо исходные коды библиотеки мигрируют под другую
систему контроля версий, то всё равно, правила описанные ниже
останутся в силе, так как они разрабатывались с целью увеличить
эффективность работы с любой системой, которая контролирует
исходный текст на уровне текстовых строк. SVN для Arageli выбрана потому,
что это система является стандартом де-факто для бесплатных
систем контроля версий.

Излагаемые правила нацелены на то, чтобы как можно больше изменений в исходном
коде было под контролем. Целью правил (похоже не достижимой в реальном
мире) является изменение исходных файлов так, чтобы
ни один участок кода внутри исходных файлов не терял
свою историю изменений на последней ревизии.
Также правила минимизируют до разумного уровня число строк исходного
текста, который подвергается изменениям.

К сожалению (в среднем по разработчикам) то как изменяется исходный
код, не соответствует лучшим практикам работы с системой контроля
версий. Например, такие ``техники'' как copy-paste для участков
кода внутри одного файла или между файлами чреваты потерей истории
для этих участков. Хотя, с использованием SVN copy-paste для файлов
целиком можно сделать так, чтобы сохранить историю для скопированного
файла.

\subsection{Минимизация бесконтрольного копирования}

Когда участок кода переносится или копируется внутри одного файла
или между файлами, то информация об истории изменений этого участка
утрачивается. Следовательно, надо избегать такого копирования.

Если пишется какой-то код, то его желательно сразу писать именно
в том месте, в котором он должен быть. Не надо писать код в месте,
для которого заранее известно, что он будет перенесён от туда.

Например, если пишется код функции класса в hpp-файле,
то предполагается, что она будет встроенной (inline), и код там
и останется. Но, если заранее известно, что финальная версия
функции не будет встраиваться, то следует сразу разместить код
в соответствующем cpp-файле, даже если эта функция имеет пустое
тело на момент написания начальной версии.

Если же без копирования не обойтись, то при внесении кода в репозиторий
(SVN Commit), следует в комментарии для ревизии точно описать,
что и куда перенесено или скопировано. Не следует экономить
на комментариях при создании ревизии в SVN в таком случае.
Вообще не стоит экономить на комментариях.

При создании файла на основе другого файла, когда существенная
часть исходного файла сохраниться и на лицо преемственность
содержимого, следует использовать копирование под контролем
версий (versioned file copy). Часто это происходит при создании
файла из шаблона.

Этой же командой следует пользоваться если надо по какой-то
причине просто скопировать файл из одного места дерева
каталогов Arageli в другое. Заметим, что такой операции
следует избегать, --- почему бы просто не пользоваться
оригинальным файлом вместо его копирования?

Другую операцию, --- перенесение файла, --- тоже следует делать
под контролем версий (versioned file move). Это же касается
переименования файла, его тоже следует делать средствами SVN,
чтобы избежать обрыва истории содержимого файла.

\subsection{Минимизация количества строк с изменениями}

Большинство доступных систем контроля версий контролируют
изменение текстового файла на уровне отдельных строк.
Поэтому если вдруг вздумается заменить все символы табуляции,
используемые для отступов, в каком-либо файле на пробелы,
то это, скорее всего затронет все непустые строки в файле.
Если посмотреть на Diff для такого файла, то на первый взгляд
может показаться, что файл переписали заново.

Следует избегать подобных изменений и заботиться заранее о
том, чтобы их не пришлось делать в будущем
(для примера выше: сразу использовать
4 пробела вместо табуляции, как требуется в настоящем документе).

\subsection{Минимизация концептуальных изменений}

Концептуально единственное изменение может затрагивать
много строк кода. Например, если вдруг решено заменить
в некотором файле переменную \lstinline$x$ на переменную
\lstinline$y$, то даже если это изменение коснётся сотен
строк кода, это всё равно считается концептуально одним
изменением.

Изменение определяется своей целью. Для чего делается
изменение? В предыдущем случае для того, чтобы заменить
имя переменной. Единственное изменение может включать
в себя правку грамматики во всех комментариях файла, или
написание кода новой функции, или создание прототипа
класса, или исправление какой-либо ошибки, или создание нового
файла или что-нибудь ещё.

Создание новой версии в системе контроля версий может
включать несколько таких изменений. Но, количество этих
изменений должно быть минимальным на версию. Следует
так же минимизировать число изменений, которые не закончены
и будут продолжены в следующих версиях. Лучше не работать
над несколькими изменениями сразу и не создавать версии
с большим количеством незаконченных изменений, а создавать
одно законченное концептуальное изменение на одну версию.
Для каждого из больших продолжительных концептуальных
изменений (например, реализация нового типа данных со
всеми операциями) следует создать отдельную ветвь разработки
(см. далее).

Следование этому правилу позволяет более чётко отследить
эволюцию кода на концептуальном уровне, т.\,е. не на уровне
изменённых строк, а на уровне концептуальных изменений.
История изменений станет более ясной и в ней будет намного
легче ориентироваться.

Если же смешения концептуальных изменений в одной версии
не избежать, то следует хотя бы воздержаться от того,
чтобы они пересекались по файлам или, тем более, по
строкам исходного кода. Если они не пересекаются
по файлам, то это позволяет, например, откатить
(SVN Revert) один из файлов не затрагивая другие.

Конечно, если делается множество мелких концептуальных
изменений, то кажется несколько странным делать для каждого
из них по новой версии. В данном случае целесообразно
объединить их в одну версию и дать исчерпывающий
комментарий для этой версии с перечислением всех
концептуальных изменений.

Может показаться, что это правило нацелено на то,
чтобы уменьшить число версий. Это не так: разработчик
делает новые версии настолько часто, насколько считает нужным.
Рекомендацией является не делать версии слишком редко:
в этом случае это чревато наполнением каждой из версий
большим количеством концептуальных изменений.

\subsection{Полнота комментариев для версий}

При создании очередной версии (т.\,е. при помещении
очередного изменения в репозиторий) следует давать
ясные, грамматически чёткие комментарии. Так как
записи для версий являются последовательностью действий
в прошлом, то используется время past simple, или
просто предложения без сказуемого, если и так ясно
о чём идёт речь. Для краткости можно опускать подлежащее,
если действие записывается от первого лица (от лица,
разработчика).

Например, ``Added brief comment to
polyhedron class.'', ``Minor grammar changes in names of
local variables in functions big\_int::to\_native\_int
and big\_int::from\_native\_int.'', ``Function
intcount\_barvinok was divided into several small functions.'',
``Fixed a bug in fft multiplication algorithm that leaded operator*
for big\_int to crash on some very big numbers (>1000000 limbs).''.
Указанные комментарии достаточно коротки; в большинстве
реальных ситуациях даже для одного концептуального изменения
требуется несколько предложений.

Следует избегать комментариев типа ``Some changes.'',
``Added a file.'', ``Deleted a file'', ``File with code
was added.'', ``Test!'', ``Bug was fixed!'' и т.\,д.
Они не доставляют никакой полезной информации.
Следует писать такие комментарии, которые потом будут
понятны человеку, который эти изменения не делал.

Комментарии включают все концептуальные изменения.
Для каждого концептуального изменения следует делать
как минимум по предложению или даже по абзацу в комментарии.
Важно явно отделить одно концептуальное изменение от другого,
чтобы потом можно было легко ориентироваться в записях.

Хороший комментарий содержит не только информацию о том,
что сделано, но и почему это сделано, и зачем. Если текущая
версия предполагает внесение дополнительных изменений на
последующих ревизиях, то следует сделать анонс этих изменений.
Например, ``Changed one of the rref functions signature
to add a spectator. All rref and related functions are supposed
to be modified in the same manner in several next revisions.''.

\subsection{Основная и рабочие ветви}

[Разъяснение того, для чего нужен trunk, branches и tags.
Политика создания новой ветви. Как сливать (merge) и синхронизировать.]

\subsection{Сторонние разработчики}

[Как сторонним разработчикам, т.\,е. по определению тем,
кто не имеет доступ к хранилищу исходных текстов Arageli,
внести свои изменения в библиотеку. Патчи SVN.]
